# ファイルに保存
print(*df["name"],sep="\n",file=codecs.open('col1.txt', 'w', 'utf-8'))
df.to_csv('nantoka.txt', header=False, index=False, sep='\t', mode='w')

# pklファイルへのオブジェクトの保存と読み出し
import pickle
pickle.dump(obj = res,file = open('026.pkl', 'wb'))
tmp = pickle.load(open("026.pkl","rb"))

# linuxコマンド
## 行数を取得
wc popular-names.txt
## 置換え
sed -e 's/\t/ /g' popular-names.txt > sedtest.txt
tr '\t' ' ' < popular-names.txt > trtest.txt
expand --tabs=1 popular-names.txt > expandtest.txt
## 抜き出し
cut -f 1 popular-names.txt > col1-2.txt
## 結合
paste col1.txt col2.txt > 013-2.txt
## 先頭10行確認
head popular-names.txt
## 末尾10行確認
tail popular-names.txt
## ファイルをN分割する
split -d -n 3 popular-names.txt 016-2-
## ソートする
sort -k 3 -n -r popular-names.txt > 018-2.txt
## ユニークな値の出現頻度の高い順に並べて表示
sort col1.txt | uniq -c | sort -k 1 -n -r > 019-2.txt

# 正規表現
## 文字のマッチング
. # ドットはDOTALLを指定しない場合は改行以外のすべての文字
[a-z] #文字クラス[]
[^5] #[]内での補集合^ この例は5以外の文字とマッチする
[\[] #バックスラッシュはクラス内での特殊文字のエスケープ
[\w] #バックスラッシュは続くコードと合わせてよく使う文字集合を表す
\d #任意の十進数とマッチ [0-9] と同じ
\D #任意の非数字文字とマッチ [^0-9] と同じ
\s #任意の空白文字とマッチ [\t\n\r\f\v] と同じ
\S #任意の非空白文字とマッチ [^ \t\n\r\f\v] と同じ
\w #任意の英数文字および下線とマッチ [a-zA-Z0-9_] と同じ
\W #任意の非英数文字とマッチ [^a-zA-Z0-9_] と同じ
## 繰返し
* # 特殊文字 * は直前の文字 (クラス)がぴったり1回ではなく0回以上繰り返されるパターンを指定
*? # 特殊文字 *? は0回以上の繰り返しにマッチ(最短一致)
+ # 特殊文字 + は1回以上の繰り返しにマッチ
+? # 特殊文字 +? は1回以上の繰り返しにマッチ(最短一致)
? # 特殊文字 ? は0か1回のどちらかにマッチ
?? # 特殊文字 ?? は0か1回のどちらかにマッチ(最短一致)
{m,n} #繰り返しの修飾子 mとnは10進整数。この修飾子は最低m回、最大でn回の繰り返すことを意味する。
## 正規表現のコンパイル
re.compile(r"ab*",re. ) # r" " でraw string記法を使ってバックスラッシュ減らすべき
## マッチのメソッド
match() -> matchオブジェクト #文字列の先頭で正規表現とマッチするか判定。matchオブジェクトにはgroup(),span()とか使える
search() #文字列を操作して、正規表現がどこにマッチするか調べます。
findall() -> list #正規表現にマッチする部分文字列を全て探しだしリストとして返します。
finditer() -> iter #正規表現にマッチする部分文字列を全て探しだし iterator として返します。
## コンパイルフラグ
ASCII, A # \w, \b, \s, そして \d などをそれぞれのプロパティをもつ ASCII 文字だけにマッチさせます。
DOTALL, S # . を改行を含む任意の文字にマッチするようにします。通常は改行以外のすべての文字
IGNORECASE, I # 大文字小文字を区別しないマッチを行います。
LOCALE, L # ロケールに対応したマッチを行います。
MULTILINE, M # ^ や $ の意味を変更し、複数行文字列に対するマッチングを行います。
VERBOSE, X ('X' は 'extended' の 'X') # 冗長な正規表現を利用可能にする。よりきれいで理解しやすくできる
## さらなる特殊文字
| # or
^ # 行の先頭にマッチ。MULTILINEモードでは文字列内の各改行の直後にマッチします。
$ # 文字列の末尾にマッチ。MULTILINEモードでは改行文字の直前として定義される。
\A # 文字列の先頭とマッチ
\Z # 文字列の末尾とマッチ
\b # 単語の境界。ゼロ幅アサーションで単語の始まりか終わりにのみマッチ。単語(英数文字のシーケンス)で終わりは空白か非英数文字として表われます。
\B # 別のゼロ幅アサーションで、 \b と逆で、現在の位置が単語の境界でないときにのみマッチします。
## 取り出さないグループと名前つきグループ
(?:[abc]) # 正規表現の一部として使いつつ、その内容は取り出さないグループを記述できる
(?P<name>...) # 名前付きグループ


